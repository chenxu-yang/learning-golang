# 语法

## 基本类型

```
bool

string

int  int8  int16  int32  int64
uint uint8 uint16 uint32 uint64 uintptr

byte // uint8 的别名

rune // int32 的别名
    // 表示一个 Unicode 码点

float32 float64

complex64 complex128
```

没有明确初始值的变量声明会被赋予它们的 **零值**。

## make 和 new 的差别

new(T) 为一个 T 类型新值分配空间并将此空间初始化为 T 的零值，返回的是新值的地址，也就是 T 类型的指针 \*T，该指针指向 T 的新分配的零值。

make 只能用于 slice,map,channel
make(T, args) 返回的是初始化之后的 T 类型的值，这个新值并不是 T 类型的零值，也不是指针 \*T，是经过初始化之后的 T 的引用。

go 的函数默认都是按值穿参，即通过函数传递的参数是值的副本，在函数内部对值修改不影响值的本身，但是 make(T, args) 返回的值通过函数传递参数之后可以直接修改，即 map，slice，channel 通过函数穿参之后在函数内部修改将影响函数外部的值。

```
func modifySlice(s []int) {
    s[0] = 1
}

s2 := make([]int, 3)
fmt.Printf("%#v", s2) //[]int{0, 0, 0}
modifySlice(s2)
fmt.Printf("%#v", s2) //[]int{1, 0, 0}
```

## method

go 方法作用是作用在接收者上的一个函数，接收者是某种类型的变量。

```
func (recv receiver_type) methodName(parameter_list) (return_value_list) { ... }

```

类型和定义的方法必须在同一个包里定义

函数将变量作为参数：Function1(recv)
方法在变量上被调用：recv.Method1()

## interface

接口提供了一种方式来 说明 对象的行为：如果谁能搞定这件事，它就可以用在这儿。

实现多态

接口定义了一组方法（方法集），但是这些方法不包含（实现）代码：它们没有被实现（它们是抽象的）。接口里也不能包含变量。

```
type Namer interface {
    Method1(param_list) return_type
    Method2(param_list) return_type
    ...
}

```

类型（比如结构体）实现接口方法集中的方法，每一个方法的实现说明了此方法是如何作用于该类型的：即实现接口，
类型不需要显式声明它实现了某个接口：接口被隐式地实现。多个类型可以实现同一个接口。

实现某个接口的类型（除了实现接口方法外）可以有其他的方法。

一个类型可以实现多个接口。

接口类型可以包含一个实例的引用， 该实例的类型实现了此接口（接口是动态类型）
接口是一种契约，实现类型必须满足它，它描述了类型的行为，规定类型可以做什么。接口彻底将类型能做什么，以及如何做分离开来，使得相同接口的变量在不同的时刻表现出不同的行为，这就是多态的本质。

在接口上调用方法时，必须有和方法定义时相同的接收者类型或者是可以从具体类型 P 直接可以辨识的：

- 指针方法可以通过指针调用
  值方法可以通过值调用
  接收者是值的方法可以通过指针调用，因为指针会首先被解引用
  接收者是指针的方法不可以通过值调用，因为存储在接口中的值没有地址
  类型 *T 的可调用方法集包含接受者为 *T 或 T 的所有方法集
  类型 T 的可调用方法集包含接受者为 T 的所有方法
  类型 T 的可调用方法集不包含接受者为 \*T 的方法

当一个类型包含（内嵌）另一个类型（实现了一个或多个接口）的指针时，这个类型就可以使用（另一个类型）所有的接口方法。

##接口总结
go 没有类，而是松耦合的类型、方法对接口的实现
OO 最重要的三个方面：封装，继承和多态

1. 封装：
   1） 包范围内的：通过标识符首字母小写，对象只在它所在的包内
   2） 可导出的：通过标识符首字母大写，对象对所在包以外也可见

2. 继承：
   内嵌一个（或多个）包含想要的行为的类型
3. 多态:
   用接口实现，某个类型的实例可以赋给它所实现的任意接口类型的变量。

# I/O

## read

Scanln 扫描来自标准输入的文本，将空格分隔的值依次存放到后续的参数内，直到碰到换行。Scanf 与其类似，除了 Scanf 的第一个参数用作格式字符串，用来决定如何读取。Sscan 和以 Sscan 开头的函数则是从字符串读取，

## write

```
outputFile, outputError := os.OpenFile(“output.dat”, os.O_WRONLY|os.O_CREATE, 0666)

```

0666 必须使用，表示权限
